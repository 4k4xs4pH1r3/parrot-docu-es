#Scripting

##Hola parrot

NOTA: Los comandos que se muestran están pensados para escribirlos en un archivo de texto y no en la terminal, a no ser que se indique lo contrario.

NOTA2: 


Bash es principalmente un lenguaje de scripting, a parte de una shell. Vamos a introducirnos en el maravilloso mundo de scripting, comenzando por el consabido script "Hola Mundo". Usted puede crear scripts simplemnete abriendo su editor de texto favorito y guardándolo. Aunque no es necesario que nuestros scripts tengan una extesion de archivo, generalmente se utiliza .sh como referencia. En nuestros ejemplos usaremos .sh

	#!/bin/bash         
	# Sscript hola ParrotSec
	echo "Hola ParrotSec"




En la primera linea del script simplemente definimos el interprete a utilizar. NOTA: No hay espacio antes de  #!/bin/bash. 
En la segunda linea podemos ver un comentario. Cualquier cosa que empiece por '#', salvo '#!' que apareció en la primera linea, será tomado por el interprete como un comentario y no se ejecuatará. Acostumbrese a escribir sus scripts con estos comentarios, para explicar lo que va haciendo y posteriormente pueda revisar su código de una manera más fácil.
En la tercera linea utilizamos la instrucción echo para mostrar un texto por pantalla. En nuestro caso "Hola ParrotSec".
Guardamos el script en la ubicación que deseemos con el nombre "hola_parrot.sh", o cualquier otro que deseemos.

Y eso es todo. Muy sencillo verdad?.


Para poder ejecutar el script, el archivo debe tener los permisos correctos. Para cambiar los permisos utilizaremos la instruccion chmod (change mode) así:

	$ chmod u+x /Path/donde/este/el/archivo/hola_parrot.sh   #Añade permiso de ejecución al usuario propietario del script
	# O
	$ chmod 700 /Path/donde/este/el/archivo/hola_parrot.sh   #Otorga control total al usuario propietario, eliminando el acceso al resto de usuarios

Esto nos dará los permisos necesarios para poder ejecutar el script. Ahora puede abrir un terminal y ejecutar el script de la siguiente manera:

	$ /Path/donde/este/el/archivo/hola_parrot.sh

Si todo es correcto podrá ver el texto "Hola Parrotsec" por pantalla. Felicidades!!! Acaba de crear su primer Bash script.

CONSEJO: Si escribe en la terminal

	$ pwd

Podrá ver el directorio en el que usted está trabajando (pwd es un comando que le muestra la ruta en la que está situado. Si su path actual es /Path/donde/este/el/archivo/, el comando anterior podría reducirse de la siguiente forma:

	$ pwd
	/Path/donde/este/el/archivo
	$ ./hola_parrot.sh



Es el momento de ver cosas más interesantes, Variables!


#Variables

Las variables, básicamente, guardan información que puede variar (o no). Quedemonos con el dato de que guardan información.
Usted puede crear y asignar valores a una variable de la siguiente forma:

	var="PARROT"

El nombre de la variable puede ser culaquier cadena de texto sin espacios, siempre y cuando no comience por un numero. A esta variable (en nuestro caso la hemos llamado 'var') le podremos asignar cualquier cadena de texto o número.

Para poder extraer el contenido de una variable simplemente utilizaremos el nombre de dicha variable precedida por el simbolo "$", como indicamos en el siguiente ejemplo:

	var="PARROT"
	echo $var

Escriba las dos lineas anteriores en un terminal. Verá que la primera linea no devuelve nada más que el prompt. Al pulsar enter, tras introducir la segunda linea, el sistema escribirá en pantalla PARROT.

Creemos un script que nos solicite información para mostrarla por pantalla.

	#!/bin/bash
	clear
	echo "Introduzca su nombre:"
	read nombre
	echo "Introduzca su distribución favorita:"
	read distribucion
	echo "Introduzca la marca de su PC/Laptop:"
	read PC
	echo "$nombre!! no sería fabuloso instalar $distribucion en su equipo $PC?"

La instrucción 'read' le permite al usuario introducir información, y guardar dicha información en una variable con el nombre definido después de 'read'.  'read' tomará la cadena introducida, para guardarla en $variable. Podemos acceder a su contenido mediante la instrucción 'echo' para así formar una frase.  Vamos a realizar unos cambios en nuestro script:

	#!/bin/bash
	clear
	read -p "Introduzca su nombre: " nombre
	read -p "Introduzca su distribución favorita: " distribucion
	read -p "Introduzca la marca de su PC/Laptop: " PC
	echo "$nombre!! no sería fabuloso instalar $distribucion en su equipo $PC?"


#Estructuras de control: Si condicional
La estructura condicional se puede utilizar para ejecutar algo en función de un resultado dado que comprobaremos o realizar otra acción en el caso de que no se haya producido dicho resultado. Por ejemplo, podríamos consultar una variable y comprobar si su valor es 'PARROT', en el caso de que fuese así podriamos mostrar un texto y si fuese cualquier otro valor , mostrariamos otro texto diferente.

El formato para construir estructuras de control condicionales es:

	if [condicion]
        then
		comandos

       	elif [condicion]
       	then
		comandos
	else if [condicion]
	then
		comandos 

      	else
		comandos
	fi

Las lineas  else if, else o  elif no son estricatamente necesarias, pero se podrá utilizar si se desea.
Es importante cerrar las estructuras de control condicionales para indicar que se han terminado las instrucciones de esta estructura. Para ello utilizaremos "fi".
Veamos un ejemplo

Comprobemos el valor introducido por un usuario y mostremos diferentes textos en función de dicho valor:

	#!/bin/bash
	echo "Introduzca el nombre de su distribución favorita:"
	read distribucion

	if [ $distribucion = parrot ]
        then 
		echo "A todos nos gusta ParrotSEC"
        else 
		echo "$distribucion está bien. Pero pruebe Parrot"
	fi

En el ejemplo anterior, en la estructura de control:

	si [ el contenido de distribucion es 'parrot'  ]
       	entonces 
		di "A todos nos gusta ParrotSEC"
        si no 
	entonces 
		di "$distribucion está bien. Pero pruebe Parrot"
	fin

La estructura condicional es un concepto sencillo ya que se parece mucho al concepto condicional que utilizamos al hablar, utilizando "si [esto] haz instruccion". Las estructuras condicionales se pueden encadenar. Piense en otro ejemplo. Añadamos una condicón más a nuestro ejemplo anterior. Supongamos que queremos controlar si el usuario introduce la distribución "Debian". Es decir, si introduce "parrot" mostramos el texto ya conocido y si es cualquier otra cosa, mostraremos el texto correspondiente. Pero ahora queremos controlar la salida de texto para la opción "Debian".

Veamos dos formas de hacerlo y elija la que más le guste (solo mostraré como queda la estructura de control y no todo el script):

	if [ $distribucion = parrot ]
	then
		echo "A todos nos gusta ParrotSEC"
	else
		if [ $distribucion = debian ]
		then
			echo "Debian es el maestro"
		else
			echo "$distribucion está bien. Pero pruebe Parrot"
		fi
	fi

otra forma:
	if [ $distribucion = parrot ]
	then
		echo "A todos nos gusta ParrotSEC"
	elif [ $distribucion = debian ]
	then
		echo "Muy bien por Debian, intente instalar Parrot"
	else
		echo "$distribucion está bien. Pero pruebe Parrot"
	fi 
			

Esta última forma nos permite escribir de forma sencilla condicionales que bien podrían ir encadenadas (ejemplo 1), pero que requeririan mayor atención, sobre todo en el cierre de estas condiciones (fi). Hay otras formas de tener el control de condiciones multiples pero hablaremos más adelante de esto.



Hemos visto como podemos controlar condiciones sobre cadenas de texto, pero podemos ejecutar estructuras de control condicional sobre valores alfanúmericos.
Podríamos utilizar condiciones del estilo "Si variable es mayor o igual que un numero dado, resta 1 a variable", "Si una variable es menor que un valor dado, suma 3 a variable2",...

Ejemplo: 
	#!/bin/bash
	echo "Introduzca un valor:"
	read valor
	if [ $ valor -ge 5 ]
	then 
		echo "El valor introducido es mayor o igual a 5"
	else
		echo "El valor introducido es menor de 5"
	fi




La condición dada y traducida al "español" sería la siguiente: "si el valor de $valor es mayor o igual a 5". ge significa "Greater or Equal than" (moyor o igual que).

Las siguientes tablas estan sacadas del man de test (man test):


##Operdores para cadenas de texto 
Operador		Verdad (TRUE) si:
------------------------------------------
cadena1 = cadena2	cadena1 es igual a cadena2
cadena1 != cadena2	cadena1 no es igual a cadena2
cadena1 < cadena2	cadena1 es menor que cadena2
cadena1 > cadena 2	cadena1 es mayor que cadena 2
-n cadena1		cadena1 no es igual al valor nulo (longitud mayorque 0)
-z cadena1		cadena1 tiene un valor nulo (longitud 0)



##Operadores para valores alfanuméricos
Operador		Verdad (TRUE) si:
------------------------------------------
x -lt y			x menor que y
x -le y			x menor o igual que y
x -eq y			x igual que y
x -ge y			x mayor o igual que y
x -gt y			x mayor que y
x -ne y			x no igual que y



##Operadores para ficheros
Operador		Verdad (TRUE) si:
------------------------------------------
-d fichero		fichero existe y es un directorio
-e fichero		fichero existe
-f fichero		fichero existe y es un fichero regular (no un
			directorio, u otro tipo de fichero especial)

-r fichero		Tienes permiso de lectura en fichero
-s fichero		fichero existe y no esta vacio
-w fichero		Tienes permiso de escritura en fichero
-x fichero		Tienes permiso de ejecucion en fichero (o de busqueda
			si es un directorio)

-O fichero		Eres el dueño del fichero
-G fichero		El grupo del fichero es igual al tuyo.

fichero1 -nt fichero2	fichero1 es mas reciente que fichero2
fichero1 -ot fichero2	fichero1 es mas antiguo que fichero2



Existen más operadores. Uno para combinar diversas condiciones '&&'(AND) y '||'(OR). Y '!'  para negar una condición.

	 
	
Storing application stdout to a variable:

Application stdout ( what you see on the terminal screen, with an un-piped application ) can be saved and used in Bash. The simplest and most elegant way is to use command substitution, by wrapping the code in $(...)

Example

fooVar=$(who)
echo $fooVar

This code should output the current users, their respective ttys, and date of login. Note that this strips newlines. Be sure to do any parsing in line ( | grep, etc ) and then pass it to a variable. We will try this again, but grep for tty7, the GUI's tty.

Example 2

fooVar=$(who | grep tty7)
echo $fooVar

This should output the single user that is currently logged into the WM. Let's move on to more advanced data manipulation within command substitution.

FUNctions
 
Bash lets you create a function on the fly, really handy if you plan on using a code block more then once. Functions reduce the amounts of editing you have to do in a script, if and when you have to update your script. Let's get to it!

Example

Here is an example script:

echo "echo is Called"
echo "Functions are FUN!"
echo "echo is Called"

Although this example is simple, you can see that if you want to change "echo is Called" to say "foo is Called" you would have to edit twice.

Below is the same app using functions.

echoFunction() {
  echo "echo is Called"
}
fooBar() {
  echo "Functions are FUN!"
}

echoFunction;
fooBar;
echoFunction;
# You call functions without (), just the function name then a semicolon.

This example, as you can see may be longer now, but you can imagine how, adding features, this will eliminate code and reduce complexity. Also, you can see if you want to change the echo call, you have to edit one line, not two.

Debugging

I always find it useful to trace a script to find out why something does not work as expected. To trace, start it through bash explicitly and use the -x option, like so:

bash -x ./script.sh

This will write each command to standard error (preceded by a ‘+ ’) before it is executed.

Other Scripting Languages related to Bash

tr

tr is one of the most basic applications to pipe data through that uses a basic scripting syntax. In this case, it accepts Regular Expressions. Let's do a normally complicated task, transforming a string to all uppercase.

Example

read foo
var=$(echo $foo | tr "{a-z}" "{A-Z}")
 # {a-z} Matches a through z
 # {A-Z} matches A through Z
echo $var

The output should look something like this:

this is a test
THIS IS A TEST

tr also can TRanslate strings, so let's translate all "tar" in $foo to "bar".

Example

echo "Type in: I love tars"
read foo
var=$(echo $foo | tr "t" "b")
echo $var

the output should look something like this:

I love tars
I love bars

AWK

AWK ( Short for Aho, Weinberger & Kernighan )

awk has its own custom scripting language, suitable for a tutorial by itself, so I will cover only the basics to help assist when you are bash scripting. This is not meant to be complete or comprehensive in any way.

pidof clone

Let's make a quick pidof clone that prompts for a process identifier, then echoes the process ID.

read pname
ps -ef | grep -v grep | grep $pname | awk '{print $2}'

Let's take some pipes out and use only awk for the filtering

read pname
ps -ef | awk -v p=${pname} '$8 ~ p { print $2 }'

Single quotes are used to pass the awk command(s). The curly braces are to use the awk language (for stuff like prints, ifs, etc.). Print prints the column passed given by the $ markup, space delimited.

The awk -v option allow passing a shell value into an awk variable, the $8 is a field variable (column 8 of the ps -ef command's output) and the operator ~ is a regular expression match.

There are a lot more commands than the print command, including if statements, etc., and is worth looking into if you are interested in what you see here!

SED

sed is one of the most complicated scripting languages on the GNU / Linux system. I am only going to cover the s/ command here.

Basic Substitution

Try this out to show that sed can not only replace inline, but unlike tr, replace with a longer or shorter string than before.

read foo
echo $foo | sed "s/foo/bars/"

When this command is run, it should substitute the first appearance of "foo" with "bars".

This is an example of the output.

I love to go to foo
I love to go to bars




https://en.wikibooks.org/wiki/Bash_Shell_Scripting
