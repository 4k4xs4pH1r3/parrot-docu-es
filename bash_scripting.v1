#Scripting

##Hola parrot

NOTA: Los comandos que se muestran están pensados para escribirlos en un archivo de texto y no en la terminal, a no ser que se indique lo contrario.

NOTA2: 


Bash es principalmente un lenguaje de scripting, a parte de una shell. Vamos a introducirnos en el maravilloso mundo de scripting, comenzando por el consabido script "Hola Mundo". Usted puede crear scripts simplemnete abriendo su editor de texto favorito y guardándolo. Aunque no es necesario que nuestros scripts tengan una extesion de archivo, generalmente se utiliza .sh como referencia. En nuestros ejemplos usaremos .sh

	#!/bin/bash         
	# Sscript hola ParrotSec
	echo "Hola ParrotSec"




En la primera linea del script simplemente definimos el interprete a utilizar. NOTA: No hay espacio antes de  #!/bin/bash. 
En la segunda linea podemos ver un comentario. Cualquier cosa que empiece por '#', salvo '#!' que apareció en la primera linea, será tomado por el interprete como un comentario y no se ejecuatará. Acostumbrese a escribir sus scripts con estos comentarios, para explicar lo que va haciendo y posteriormente pueda revisar su código de una manera más fácil.
En la tercera linea utilizamos la instrucción echo para mostrar un texto por pantalla. En nuestro caso "Hola ParrotSec".
Guardamos el script en la ubicación que deseemos con el nombre "hola_parrot.sh", o cualquier otro que deseemos.

Y eso es todo. Muy sencillo verdad?.


Para poder ejecutar el script, el archivo debe tener los permisos correctos. Para cambiar los permisos utilizaremos la instruccion chmod (change mode) así:

	$ chmod u+x /Path/donde/este/el/archivo/hola_parrot.sh   #Añade permiso de ejecución al usuario propietario del script
	# O
	$ chmod 700 /Path/donde/este/el/archivo/hola_parrot.sh   #Otorga control total al usuario propietario, eliminando el acceso al resto de usuarios

Esto nos dará los permisos necesarios para poder ejecutar el script. Ahora puede abrir un terminal y ejecutar el script de la siguiente manera:

	$ /Path/donde/este/el/archivo/hola_parrot.sh

Si todo es correcto podrá ver el texto "Hola Parrotsec" por pantalla. Felicidades!!! Acaba de crear su primer Bash script.

CONSEJO: Si escribe en la terminal

	$ pwd

Podrá ver el directorio en el que usted está trabajando (pwd es un comando que le muestra la ruta en la que está situado. Si su path actual es /Path/donde/este/el/archivo/, el comando anterior podría reducirse de la siguiente forma:

	$ pwd
	/Path/donde/este/el/archivo
	$ ./hola_parrot.sh



Es el momento de ver cosas más interesantes, Variables!


#Variables

Las variables, básicamente, guardan información que puede variar (o no). Quedemonos con el dato de que guardan información.
Usted puede crear y asignar valores a una variable de la siguiente forma:

	var="PARROT"

El nombre de la variable puede ser culaquier cadena de texto sin espacios, siempre y cuando no comience por un numero. A esta variable (en nuestro caso la hemos llamado 'var') le podremos asignar cualquier cadena de texto o número.

Para poder extraer el contenido de una variable simplemente utilizaremos el nombre de dicha variable precedida por el simbolo "$", como indicamos en el siguiente ejemplo:

	var="PARROT"
	echo $var

Escriba las dos lineas anteriores en un terminal. Verá que la primera linea no devuelve nada más que el prompt. Al pulsar enter, tras introducir la segunda linea, el sistema escribirá en pantalla PARROT.

Creemos un script que nos solicite información para mostrarla por pantalla.

	#!/bin/bash
	clear
	echo "Introduzca su nombre:"
	read nombre
	echo "Introduzca su distribución favorita:"
	read distribucion
	echo "Introduzca la marca de su PC/Laptop:"
	read PC
	echo "$nombre!! no sería fabuloso instalar $distribucion en su equipo $PC?"

La instrucción 'read' le permite al usuario introducir información, y guardar dicha información en una variable con el nombre definido después de 'read'.  'read' tomará la cadena introducida, para guardarla en $variable. Podemos acceder a su contenido mediante la instrucción 'echo' para así formar una frase.  Vamos a realizar unos cambios en nuestro script:

	#!/bin/bash
	clear
	read -p "Introduzca su nombre: " nombre
	read -p "Introduzca su distribución favorita: " distribucion
	read -p "Introduzca la marca de su PC/Laptop: " PC
	echo "$nombre!! no sería fabuloso instalar $distribucion en su equipo $PC?"


#Estructuras de control: condicional (if)
La estructura condicional se puede utilizar para ejecutar algo en función de un resultado dado que comprobaremos o realizar otra acción en el caso de que no se haya producido dicho resultado. Por ejemplo, podríamos consultar una variable y comprobar si su valor es 'PARROT', en el caso de que fuese así podriamos mostrar un texto y si fuese cualquier otro valor , mostrariamos otro texto diferente.

El formato para construir estructuras de control condicionales es:

	if [condicion]
        then
		comandos

       	elif [condicion]
       	then
		comandos
	else if [condicion]
	then
		comandos 

      	else
		comandos
	fi

Las lineas  else if, else o  elif no son estricatamente necesarias, pero se podrá utilizar si se desea.
Es importante cerrar las estructuras de control condicionales para indicar que se han terminado las instrucciones de esta estructura. Para ello utilizaremos "fi".
Veamos un ejemplo

Comprobemos el valor introducido por un usuario y mostremos diferentes textos en función de dicho valor:

	#!/bin/bash
	echo "Introduzca el nombre de su distribución favorita:"
	read distribucion

	if [ $distribucion = parrot ]
        then 
		echo "A todos nos gusta ParrotSEC"
        else 
		echo "$distribucion está bien. Pero pruebe Parrot"
	fi

En el ejemplo anterior, en la estructura de control:

	si [ el contenido de distribucion es 'parrot'  ]
       	entonces 
		di "A todos nos gusta ParrotSEC"
        si no 
	entonces 
		di "$distribucion está bien. Pero pruebe Parrot"
	fin

La estructura condicional es un concepto sencillo ya que se parece mucho al concepto condicional que utilizamos al hablar, utilizando "si [esto] haz instruccion". Las estructuras condicionales se pueden encadenar. Piense en otro ejemplo. Añadamos una condicón más a nuestro ejemplo anterior. Supongamos que queremos controlar si el usuario introduce la distribución "Debian". Es decir, si introduce "parrot" mostramos el texto ya conocido y si es cualquier otra cosa, mostraremos el texto correspondiente. Pero ahora queremos controlar la salida de texto para la opción "Debian".

Veamos dos formas de hacerlo y elija la que más le guste (solo mostraré como queda la estructura de control y no todo el script):

	if [ $distribucion = parrot ]
	then
		echo "A todos nos gusta ParrotSEC"
	else
		if [ $distribucion = debian ]
		then
			echo "Debian es el maestro"
		else
			echo "$distribucion está bien. Pero pruebe Parrot"
		fi
	fi

otra forma:
	if [ $distribucion = parrot ]
	then
		echo "A todos nos gusta ParrotSEC"
	elif [ $distribucion = debian ]
	then
		echo "Muy bien por Debian, intente instalar Parrot"
	else
		echo "$distribucion está bien. Pero pruebe Parrot"
	fi 
			

Esta última forma nos permite escribir de forma sencilla condicionales que bien podrían ir encadenadas (ejemplo 1), pero que requeririan mayor atención, sobre todo en el cierre de estas condiciones (fi). Hay otras formas de tener el control de condiciones multiples pero hablaremos más adelante de esto.



Hemos visto como podemos controlar condiciones sobre cadenas de texto, pero podemos ejecutar estructuras de control condicional sobre valores alfanúmericos.
Podríamos utilizar condiciones del estilo "Si variable es mayor o igual que un numero dado, resta 1 a variable", "Si una variable es menor que un valor dado, suma 3 a variable2",...

Ejemplo: 
	#!/bin/bash
	echo "Introduzca un valor:"
	read valor
	if [ $ valor -ge 5 ]
	then 
		echo "El valor introducido es mayor o igual a 5"
	else
		echo "El valor introducido es menor de 5"
	fi




La condición dada y traducida al "español" sería la siguiente: "si el valor de $valor es mayor o igual a 5". ge significa "Greater or Equal than" (moyor o igual que).

Las siguientes tablas estan sacadas del man de test (man test):


##Operdores para cadenas de texto 
Operador		Verdad (TRUE) si:
------------------------------------------
cadena1 = cadena2	las cadenas son iguales
cadena1 != cadena2	las cadenas no son iguales
-n cadena		la longitud de cadena no es 0
-z cadena		la longitud de cadena es 0



##Operadores para valores alfanuméricos
Operador		Verdad (TRUE) si:
------------------------------------------
x -lt y			x menor que y
x -le y			x menor o igual que y
x -eq y			x igual que y
x -ge y			x mayor o igual que y
x -gt y			x mayor que y
x -ne y			x no igual que y



##Operadores para ficheros
Operador		Verdad (TRUE) si:
------------------------------------------
-d fichero		fichero existe y es un directorio
-e fichero		fichero existe
-f fichero		fichero existe y es un fichero regular (no un
			directorio, u otro tipo de fichero especial)

-r fichero		Tienes permiso de lectura en fichero
-s fichero		fichero existe y no esta vacio
-w fichero		Tienes permiso de escritura en fichero
-x fichero		Tienes permiso de ejecucion en fichero (o de busqueda
			si es un directorio)

-O fichero		Eres el dueño del fichero
-G fichero		El grupo del fichero es igual al tuyo.

fichero1 -nt fichero2	fichero1 es mas reciente que fichero2
fichero1 -ot fichero2	fichero1 es mas antiguo que fichero2



Existen más operadores. Uno para combinar diversas condiciones '-a'(AND) y '-o'(OR). Y '!'  para negar una condición.

Veamos unos cuantos ejemplos. Por favor, lean los comentarios de los scripts.

Ej. 1:
	#!/bin/bash
	#
	# En este ejemplo comprobaremos cadenas
	#
	
	#Solicitamos al usuario que introduzca dos textos que guardaremos en variables texto1 y texto2
	read -p "Escriba un texto:" texto1
	read -p "Escriba otro texto:" texto2

	#Comprobamos si alguna cadena de texto es vacia (texto1 es vacio o texto2 es vacio)
	#Preste atención al entrecomillado para que realmente sea considerado texto
	if [ -z "$texto1" -o -z "$texto2" ]; then
		#Si entra en esta condición, no se necesita continuar con el script
		#Por lo que provocamos una salida del mismo, con un valor 1. Hablaremos de esto en algún punto posterior.
		#De momento debemos saber que exit finaliza el script y que el valor 1 es el codigo de retorno del script, porque así lo hemos indicado
		echo "Uno de los textos está vacío"
		exit 1
	fi

	#Comprobamos si texto1 es igual a texto2
	if [ $texto1 = $texto2 ]
	then
		echo "$texto1 es igual a $texto2"
	#Podriamos haber escogido simplemente else, y ahorrarnos la definición de la condición
	elif [ $texto1 != $texto2 ]; then
		# \" se utiliza para escapar las '"'. Es decir, el interprete debe saber que esas comillas no son la terminación del comando echo, sino
		# que debe mostrar esas comillas dentro de la cadena.  
		echo "El texto \"$texto1\" y el texto \"$texto2\" no es igual"
	fi

Anexo 1 Ej. 1: echo y secuencia de escape

Trate de escribir en una linea de comandos:
	$ echo "hola Parrot"

Pero... cómo escribimos un comando echo para que muestre por pantalla hola "ParrotSec"? 
echo aunque tiene diversas opciones y podemos utilizar otros simbolos para indicar el principio y el fin de la cadena de texto a mostrar, generalmente se usa con las ". Para poder mostrar una cadena con " debemos "escapar" las dobles comillas.

Mire el siguiente ejemplo:
	$ echo "hola "Parrot""

Pues bien, para que las comillas intermedias sean parte de la cadena a mostrar debemos escapar dichas comillas. Esto se hace anteponiendo un simbolo '\' al caracter especial. Esto es muy utilizado para otros comandos tambíén.Siguiendo con nuestro ejemplo, el comando quedaría de la siguiente forma:
	$ echo " hola \"Parrot\"  "

Se han añadido varios espacios en la cadena a mostrar, tanto al principio como al final, simplemente para que se vea más claro el ejemplo.	 




Ej. 2:

	#!/bin/bash
	#
	## Comparacion de valores numericos
	#

	read -p "Introduce el primer número:" NUM1
	read -p "Introduce el segundo número:" NUM2
	read -p "Introduce el tercer número:" NUM3


	# Utilizar '&&' es lo mismo que utilizar el operador '-a'
	if [ $NUM1 -ne $NUM2 ] && [ $NUM1 -ne $NUM3 ]; then
		echo "$NUM1 es diferente a $NUM2 y $NUM3"
	fi

	# Utilizar '||' es lo mismo que utilizar el operador '-o'
	if [ $NUM1 -gt $NUM3 ] || [ $NUM1 -gt $NUM2 ]; then
	        echo "$NUM1 es el número más grande de los 3 introducidos"
        fi




#Estructuras de control: condicional (case)
Podríamos considerar la estructura de control "CASE" como un formato condicional parecido al "IF". Dado un resultado de una variable, seleccionaremos unas instrucciones concretas.
El formato para construir estructuras de control CASE es:

	case $variable in
     		caso_1 )
        		comandos;;
     		caso_2 ) 
			comandos;;
  		......
	esac  



Ej. 1:
	case "$1" in
		start)
			echo "Opción pasada: Start"
			;;
		stop)
			echo "Opción pasada: Stop"
			;;
		*)
			echo "Uso: $0 {start|stop}"
			exit 1
			;;
	esac



Ej. 2:
	read opcion
	case $opcion in
		s|S)
			echo "Se ha pulsado Si"
			;;
		n|N)
			echo "Se ha pulsado No"
			;;
		*)
			echo "No es una opción contemplada"
			;;
	esac




#Estructura blucle: FOR
Para acciones repititivas se han creado estructuras en forma de bucle. Hay varios tipos. En este primer lugar veremos bucles for.

La forma que tiene esta estructura es la siguiente:
	for variable [in lista]
	do
		ejecucion
	done


Ej. 1:
	for i in 1 2 3 4 5
	do
		echo "Cuenta $i"
	done


Ej. 2:
	for i in {2..10..2}
	do
		echo "$i es par"
	do

Anexo Ej. 2:
En versiones bash anteriores a la V.3, se utilizaba normalmente un comando seq para sacar una lista de valores incrementales. En la versión 4 de bash se implementó una forma de crear estos valores incrementales dentro del propio blucle for.
No es necesario llamar ya al programa externo "seq", ya que el built-in del for aplicado en este ejemplo es más rápido. "{Primer_numero..Ultimo_numero..Incremento}"


Ej. 3:
	for (( c=1; c<=5; c++))
	do
		echo "Valor de c es : $c"
	done

Anexo Ej. 3:
Este ejemplo de for, es igual (no es extraño ya que es heredado de él) al for del lenguaje de programación C.




	
Storing application stdout to a variable:

Application stdout ( what you see on the terminal screen, with an un-piped application ) can be saved and used in Bash. The simplest and most elegant way is to use command substitution, by wrapping the code in $(...)

Example

fooVar=$(who)
echo $fooVar

This code should output the current users, their respective ttys, and date of login. Note that this strips newlines. Be sure to do any parsing in line ( | grep, etc ) and then pass it to a variable. We will try this again, but grep for tty7, the GUI's tty.

Example 2

fooVar=$(who | grep tty7)
echo $fooVar

This should output the single user that is currently logged into the WM. Let's move on to more advanced data manipulation within command substitution.

FUNctions
 
Bash lets you create a function on the fly, really handy if you plan on using a code block more then once. Functions reduce the amounts of editing you have to do in a script, if and when you have to update your script. Let's get to it!

Example

Here is an example script:

echo "echo is Called"
echo "Functions are FUN!"
echo "echo is Called"

Although this example is simple, you can see that if you want to change "echo is Called" to say "foo is Called" you would have to edit twice.

Below is the same app using functions.

echoFunction() {
  echo "echo is Called"
}
fooBar() {
  echo "Functions are FUN!"
}

echoFunction;
fooBar;
echoFunction;
# You call functions without (), just the function name then a semicolon.

This example, as you can see may be longer now, but you can imagine how, adding features, this will eliminate code and reduce complexity. Also, you can see if you want to change the echo call, you have to edit one line, not two.

Debugging

I always find it useful to trace a script to find out why something does not work as expected. To trace, start it through bash explicitly and use the -x option, like so:

bash -x ./script.sh

This will write each command to standard error (preceded by a ‘+ ’) before it is executed.

Other Scripting Languages related to Bash

tr

tr is one of the most basic applications to pipe data through that uses a basic scripting syntax. In this case, it accepts Regular Expressions. Let's do a normally complicated task, transforming a string to all uppercase.

Example

read foo
var=$(echo $foo | tr "{a-z}" "{A-Z}")
 # {a-z} Matches a through z
 # {A-Z} matches A through Z
echo $var

The output should look something like this:

this is a test
THIS IS A TEST

tr also can TRanslate strings, so let's translate all "tar" in $foo to "bar".

Example

echo "Type in: I love tars"
read foo
var=$(echo $foo | tr "t" "b")
echo $var

the output should look something like this:

I love tars
I love bars

AWK

AWK ( Short for Aho, Weinberger & Kernighan )

awk has its own custom scripting language, suitable for a tutorial by itself, so I will cover only the basics to help assist when you are bash scripting. This is not meant to be complete or comprehensive in any way.

pidof clone

Let's make a quick pidof clone that prompts for a process identifier, then echoes the process ID.

read pname
ps -ef | grep -v grep | grep $pname | awk '{print $2}'

Let's take some pipes out and use only awk for the filtering

read pname
ps -ef | awk -v p=${pname} '$8 ~ p { print $2 }'

Single quotes are used to pass the awk command(s). The curly braces are to use the awk language (for stuff like prints, ifs, etc.). Print prints the column passed given by the $ markup, space delimited.

The awk -v option allow passing a shell value into an awk variable, the $8 is a field variable (column 8 of the ps -ef command's output) and the operator ~ is a regular expression match.

There are a lot more commands than the print command, including if statements, etc., and is worth looking into if you are interested in what you see here!

SED

sed is one of the most complicated scripting languages on the GNU / Linux system. I am only going to cover the s/ command here.

Basic Substitution

Try this out to show that sed can not only replace inline, but unlike tr, replace with a longer or shorter string than before.

read foo
echo $foo | sed "s/foo/bars/"

When this command is run, it should substitute the first appearance of "foo" with "bars".

This is an example of the output.

I love to go to foo
I love to go to bars




https://en.wikibooks.org/wiki/Bash_Shell_Scripting



for

La sintaxis de esta construccion es la siguiente:
for nombre [in lista]
do
   comandos que pueden utilizar $nombre
done


Un ejemplo nos aclarara las cosas. Vamos a listar informacion en el DNS de una lista de direcciones web:
#!/bin/bash
#
#for HOST in www.google.com www.altavista.com www.yahoo.com
#do
#  echo "-----------------------"
#    echo $HOST
#      echo "-----------------------"
#        
#          /usr/bin/host $HOST
#            echo "-----------------------"
#
#            done
#
#
#            while
#
#            La sintaxis de esta construccion es la siguiente:
#            while condicion
#            do
#              comandos
#              done
#
#
#              Un ejemplo simple con while en donde escribimos el valor de una variable 10 veces, despues de incrementar su valor:
#              #!/bin/bash
#
#              NUM=0
#
#              while [ $NUM -le 10 ]; do
#                  echo "\$NUM: $NUM"
#                      let NUM=$NUM+1
#                      done
#
#
#                      until
#
#                      La sintaxis de esta construccion es la siguiente:
#                      until condicion; do
#                         comandos
#                         done
#
#
#                         Un ejemplo simple con until en donde escribimos el valor de una variable 10 veces, despues de incrementar su valor:
#                         #!/bin/bash
#
#                         NUM=0
#
#                         until [ $NUM -gt 10 ]; do
#                             echo "\$NUM: $NUM"
#                                 let NUM=$NUM+1
#                                 done
#
#
#                                 case
#
#                                 La sintaxis de esta construccion es la siguiente:
#                                 case expresion in
#                                      caso_1 )
#                                              comandos;;
#                                                   caso_2 ) 
#                                                   	comandos;;
#                                                   	     ......
#                                                   	     esac  
#
#
#                                                   	     Un ejemplo simple con case para aclarar las cosas:
#                                                   	     #!/bin/bash
#
#                                                   	     for NUM in 0 1 2 3
#                                                   	     do
#                                                   	       case $NUM in
#                                                   	             0)
#                                                   	             	  echo "\$NUM es igual a cero";;
#                                                   	             	        1)
#                                                   	             	        	  echo "\$NUM es igual a uno";;
#                                                   	             	        	        2)
#                                                   	             	        	        	  echo "\$NUM es igual a dos";;
#                                                   	             	        	        	        3)
#                                                   	             	        	        	        	  echo "\$NUM es igual a tres";;
#                                                   	             	        	        	        	    esac
#                                                   	             	        	        	        	    done
#
#
#                                                   	             	        	        	        	    select
#
#                                                   	             	        	        	        	    La sintaxis de esta construccion es la siguiente:
#                                                   	             	        	        	        	    select nombre [in lista]
#                                                   	             	        	        	        	    do
#                                                   	             	        	        	        	      comandos que pueden utilizar $nombre
#                                                   	             	        	        	        	      done
#
#
#                                                   	             	        	        	        	      Un ejemplo simple para aclarar las cosas.
#                                                   	             	        	        	        	      #!/bin/bash
#
#                                                   	             	        	        	        	      select OPCION in opcion_1 opcion_2 opcion_3
#                                                   	             	        	        	        	        do
#                                                   	             	        	        	        	          if [ $OPCION ]; then
#                                                   	             	        	        	        	                echo "Opcion elegida: $OPCION"
#                                                   	             	        	        	        	                      break
#                                                   	             	        	        	        	                        else
#                                                   	             	        	        	        	                              echo "Opcion no valida"
#                                                   	             	        	        	        	                                fi
#                                                   	             	        	        	        	                                done
#
#
#                                                   	             	        	        	        	                                Bueno esto es todo por hoy en nuestra introduccion a Bash. En el proximo articulo de esta serie veremos diferentes aspectos de la entrada y salida de datos en un script Bash.
#
